# MSBD 5017 Blockchain Group Project Source Code(Group 1)

## ZK-Resilient Protocol

**Next-Generation Privacy-Preserving Stablecoin Protocol** â€” Powered by Zero-Knowledge Proofs, Automated State Machine Risk Control, and Hybrid Governance.

This project aims to solve the opacity and centralized audit risks inherent in traditional stablecoins (like USDT). By fusing **zk-SNARKs (Privacy Audit)**, **Merkle Sum Tree (Proof of Liabilities)**, and an **Automated Dual-Layer Circuit Breaker**, it delivers a Trustless, High-Availability, and Regulatory-Compliant DeFi infrastructure.

## ğŸ“‚ Project Code Framework (Project Structure)

The project adopts a Web3-native "Light Backend, Strong Contract" architecture:

```text
zk-resilient-protocol/
â”œâ”€â”€ ğŸ“ contracts/               # On-chain Smart Contract Core Logic
â”‚   â”œâ”€â”€ ComplianceController.sol  # Core Brain: Maintains automated state machine
â”‚   â”œâ”€â”€ ResilientToken.sol        # Stablecoin ($rUSD): Integrates circuit breaker & KYC checks
â”‚   â”œâ”€â”€ Verifier.sol              # ZK Verifier: Generated by Circom
â”‚   â”œâ”€â”€ GovernanceToken.sol       # Governance Token ($RES): Used for auditor staking
â”‚   â”œâ”€â”€ MockKYC.sol               # Compliance Module: Simulates 3rd-party KYC interface
â”‚   â””â”€â”€ interfaces/               # Standard Interface Definitions (IVerifier, IKYCProvider)
â”‚
â”œâ”€â”€ ğŸ“ circuits/                # Zero-Knowledge Proof Circuits
â”‚   â””â”€â”€ solvency.circom           # Core Circuit: Proves Bank Reserves >= On-chain Supply
â”‚
â””â”€â”€ ğŸ“ scripts/                 # Off-chain Automated Infrastructure (Node.js)
    â”œâ”€â”€ mock_bank.js              # Mock Bank Data Source (Generates signed snapshots)
    â”œâ”€â”€ fetch_snapshot.js         # Captures real on-chain ledger snapshots
    â”œâ”€â”€ build_liability_tree.js   # Builds Merkle Sum Tree
    â””â”€â”€ prover_bot.js             # Heartbeat Bot: Generates Proof & submits on-chain
```

## ğŸš¦ Usage Guide: State Machine Function Testing

This guide demonstrates how to manually test the core risk control logic (Traffic Light State Machine) in **Remix IDE** without running complex ZK scripts.

### 1. Deployment & Initialization

Please deploy the contracts in the following order using Remix:

1. **Deploy `Verifier` (Mock Version)**
    * Deploy a mock verifier that always returns `true`.
    * Action: Copy its address after deployment.

2. **Deploy `MockKYC`**
    * Action: Copy its address after deployment.

3. **Deploy `ComplianceController`**
    * `_verifierAddress`: Paste the address from Step 1.
    * `_admin`: Your wallet address.
    * `_pubKeyAx` / `_pubKeyAy`: Enter any non-zero numbers (e.g., `123`, `456`).
    * **âš ï¸ Important:** For testing purposes, modify the `TIMEOUT` variable in the contract code to **60** (60 seconds) before deploying.

4. **Deploy `ResilientToken`**
    * `_controller`: Paste the address from Step 3.
    * `_admin`: Your wallet address.
    * `_kycProvider`: Paste the address from Step 2.
    * `_treasury`: Any address to receive fees.

### 2. Configuration (Wire up)

Before testing transfers, you must link the contracts:

* **Link Token:**
  * Go to `ComplianceController`.
  * Call `setToken(ResilientToken_Address)`.
* **Setup KYC:**
  * Go to `MockKYC`.
  * Call `setStatus(Your_Wallet_Address, true)`.
* **Mint Initial Supply (Fund Wallet):**
  * Go to `ResilientToken`.
  * Call `mint(Your_Wallet_Address, 1000000000000000000000)`.
  * Note: Ensure you are using the Admin account (which has MINTER_ROLE).

### 3. Test Scenarios

#### âœ… Scenario A: Normal Operation (Compliant)

* **Check State:** Verify `currentState` in Controller is `0` (Compliant).
* **Action:** Call `transfer` in `ResilientToken`.
* **Result:** **Transaction Successful**. The system is healthy.

#### âš ï¸ Scenario B: Timeout Soft-Freeze (GracePeriod)

* **Trigger:** Wait for 60 seconds (simulating Prover downtime).
* **Action:** Call `checkLiveness` in Controller.
* **Check State:** `currentState` becomes `1` (GracePeriod).
* **Expected Results:**
  * `mint`: âŒ **Reverts** (Minting paused to limit risk).
  * `transfer`: âœ… **Success** (Users can still move funds).
  * `burn`: âœ… **Success** (Redemption allowed).

#### ğŸš¨ Scenario C: Emergency Hard-Freeze (Frozen)

* **Trigger:** Simulate an auditor detecting serious risk.
* **Action:** Call `emergencyFreeze` in Controller.
* **Check State:** `currentState` becomes `2` (Frozen).
* **Expected Results:**
  * `mint`: âŒ **Reverts**.
  * `transfer`: âŒ **Reverts** (Error: "System Frozen").
  * `burn`: âœ… **Success** (Exit hatch remains open).

#### â™»ï¸ Scenario D: Auto Self-Healing

* **Trigger:** Simulate the Prover node coming back online with a valid proof.
* **Action:** Call `submitAudit` in Controller.
  * `a`, `b`, `c`: Enter empty arrays (e.g., `[0,0]...`) since we use Mock Verifier.
  * `_rootHash`: Enter any bytes32 string.
  * `_totalLiabilities`: **Must match** the current `totalSupply` of the Token exactly.
* **Check State:** `currentState` instantly reverts to `0` (Compliant).
* **Result:** Try `transfer` again. **Transaction Successful**. The system has automatically unlocked.
